{"ast":null,"code":"// Set up audio context\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\nconst audioContext = new AudioContext();\n/**\n * Retrieves audio from an external source, the initializes the drawing function\n * @param {String} url the url of the audio we'd like to fetch\n */\n\nasync function drawAudio(url) {\n  return fetch(url).then(response => response.arrayBuffer()).then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer)).then(audioBuffer => {\n    return normalizeData(filterData(audioBuffer));\n  });\n}\n\n;\n/**\n * Filters the AudioBuffer retrieved from an external source\n * @param {AudioBuffer} audioBuffer the AudioBuffer from drawAudio()\n * @returns {Array} an array of floating point numbers\n */\n\nconst filterData = audioBuffer => {\n  const rawData = audioBuffer.getChannelData(0); // We only need to work with one channel of data\n\n  const samples = 170; // Number of samples we want to have in our final data set\n\n  const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n\n  const filteredData = [];\n\n  for (let i = 0; i < samples; i++) {\n    let blockStart = blockSize * i; // the location of the first sample in the block\n\n    let sum = 0;\n\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n    }\n\n    filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n  }\n\n  return filteredData;\n};\n/**\n * Normalizes the audio data to make a cleaner illustration \n * @param {Array} filteredData the data from filterData()\n * @returns {Array} an normalized array of floating point numbers\n */\n\n\nconst normalizeData = filteredData => {\n  const multiplier = Math.pow(Math.max(...filteredData), -1);\n  return filteredData.map(n => n * multiplier);\n};\n\nexport default drawAudio;","map":{"version":3,"sources":["/home/jan/sound-track-box/src/components/AudioAnalyzer.js"],"names":["window","AudioContext","webkitAudioContext","audioContext","drawAudio","url","fetch","then","response","arrayBuffer","decodeAudioData","audioBuffer","normalizeData","filterData","rawData","getChannelData","samples","blockSize","Math","floor","length","filteredData","i","blockStart","sum","j","abs","push","multiplier","pow","max","map","n"],"mappings":"AAAA;AACAA,MAAM,CAACC,YAAP,GAAsBD,MAAM,CAACC,YAAP,IAAuBD,MAAM,CAACE,kBAApD;AACA,MAAMC,YAAY,GAAG,IAAIF,YAAJ,EAArB;AAEA;AACA;AACA;AACA;;AACA,eAAeG,SAAf,CAAyBC,GAAzB,EAA8B;AAC1B,SAAOC,KAAK,CAACD,GAAD,CAAL,CACFE,IADE,CACGC,QAAQ,IAAIA,QAAQ,CAACC,WAAT,EADf,EAEFF,IAFE,CAEGE,WAAW,IAAIN,YAAY,CAACO,eAAb,CAA6BD,WAA7B,CAFlB,EAGFF,IAHE,CAGGI,WAAW,IAAI;AACjB,WAAOC,aAAa,CAACC,UAAU,CAACF,WAAD,CAAX,CAApB;AACH,GALE,CAAP;AAMH;;AAAA;AAED;AACA;AACA;AACA;AACA;;AACA,MAAME,UAAU,GAAGF,WAAW,IAAI;AAC9B,QAAMG,OAAO,GAAGH,WAAW,CAACI,cAAZ,CAA2B,CAA3B,CAAhB,CAD8B,CACiB;;AAC/C,QAAMC,OAAO,GAAG,GAAhB,CAF8B,CAET;;AACrB,QAAMC,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWL,OAAO,CAACM,MAAR,GAAiBJ,OAA5B,CAAlB,CAH8B,CAG0B;;AACxD,QAAMK,YAAY,GAAG,EAArB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAApB,EAA6BM,CAAC,EAA9B,EAAkC;AAC9B,QAAIC,UAAU,GAAGN,SAAS,GAAGK,CAA7B,CAD8B,CACE;;AAChC,QAAIE,GAAG,GAAG,CAAV;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,SAApB,EAA+BQ,CAAC,EAAhC,EAAoC;AAChCD,MAAAA,GAAG,GAAGA,GAAG,GAAGN,IAAI,CAACQ,GAAL,CAASZ,OAAO,CAACS,UAAU,GAAGE,CAAd,CAAhB,CAAZ,CADgC,CACe;AAClD;;AACDJ,IAAAA,YAAY,CAACM,IAAb,CAAkBH,GAAG,GAAGP,SAAxB,EAN8B,CAMM;AACvC;;AACD,SAAOI,YAAP;AACH,CAdD;AAgBA;AACA;AACA;AACA;AACA;;;AACA,MAAMT,aAAa,GAAGS,YAAY,IAAI;AAClC,QAAMO,UAAU,GAAGV,IAAI,CAACW,GAAL,CAASX,IAAI,CAACY,GAAL,CAAS,GAAGT,YAAZ,CAAT,EAAoC,CAAC,CAArC,CAAnB;AACA,SAAOA,YAAY,CAACU,GAAb,CAAiBC,CAAC,IAAIA,CAAC,GAAGJ,UAA1B,CAAP;AACH,CAHD;;AAKA,eAAexB,SAAf","sourcesContent":["// Set up audio context\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\nconst audioContext = new AudioContext();\n\n/**\n * Retrieves audio from an external source, the initializes the drawing function\n * @param {String} url the url of the audio we'd like to fetch\n */\nasync function drawAudio(url) {\n    return fetch(url)\n        .then(response => response.arrayBuffer())\n        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))\n        .then(audioBuffer => {\n            return normalizeData(filterData(audioBuffer));\n        });\n};\n\n/**\n * Filters the AudioBuffer retrieved from an external source\n * @param {AudioBuffer} audioBuffer the AudioBuffer from drawAudio()\n * @returns {Array} an array of floating point numbers\n */\nconst filterData = audioBuffer => {\n    const rawData = audioBuffer.getChannelData(0); // We only need to work with one channel of data\n    const samples = 170; // Number of samples we want to have in our final data set\n    const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n    const filteredData = [];\n    for (let i = 0; i < samples; i++) {\n        let blockStart = blockSize * i; // the location of the first sample in the block\n        let sum = 0;\n        for (let j = 0; j < blockSize; j++) {\n            sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n        }\n        filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n    }\n    return filteredData;\n};\n\n/**\n * Normalizes the audio data to make a cleaner illustration \n * @param {Array} filteredData the data from filterData()\n * @returns {Array} an normalized array of floating point numbers\n */\nconst normalizeData = filteredData => {\n    const multiplier = Math.pow(Math.max(...filteredData), -1);\n    return filteredData.map(n => n * multiplier);\n}\n\nexport default drawAudio;"]},"metadata":{},"sourceType":"module"}